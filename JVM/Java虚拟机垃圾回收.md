## 2、Java虚拟机垃圾回收

内存分析命令：
- jps 查看Java中的进程，和Linux的ps -ef 或 ps -aux  性质差不多
- jinfo 查看Java进程空间大小，查看系统熟悉
- jstack 查看一个纸递给的Java进程中线程的状态
- jstat 查看GC的信息
- jmap 空间中各个年龄段的空间的使用情况，

(1) 如何判定对象为垃圾对象
  - 引用计数
  - 可达性分析

(2)如何回收回收
- 回收策略
  - 标记清除
  - 复制
  - 标记整理
  - 分代收集
- 常见的垃圾回收器
  - Setial
  - Parnew
  - CMS
  - G1(**重点**)

(3) 何时回收

#### 2.1引用计数
引用计数器的实现很简单，对于一个对象A，只要有任何一个对象引用了A，则A的计数器就加1，当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，则对象A就不可能在被使用

<img src="https://i.imgur.com/UHc3B9V.jpg" width="540px" />

![]()

引用计数法的问题：
- 引用和去引用伴随着加法和减法，影响性能
- 很难处理循环引用

<img src="https://i.imgur.com/EKQ0mHi.jpg" width="540px" />

####2.2可达性分析
通过一系列的GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径就成为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

可以作为GC Roots的对象包含：
- 虚拟机栈中引用的对象(栈帧中的本地变量表)
- 方法区中的静态属性引用的对象或者常量引用的对象
- 本地方法中JNI引用的对象，其实是Native方法

####3.1标记-清除(Mark-Sweep)
 算法分为“标记”和“清除”两个阶段：

 (1)s首先标记出所欲需要回收的对象，在标记完成后统一回收所有被标记的对象，如果对象在进行根搜索后没有发现与GC roots相连接的引用链，对象也会被标记。

(2)它是最基础的手机算法，后续的算法都是根据它的缺点进行修改而得到的。

(3)主要的不足点有：效率问题，标记和清除过程效率不高，另一个是空间问题。标记清除后会产生大量的碎片空间，空间碎片太多可能导致程序在运行中需要分配较大内存时无法满足不得不提前出发一次GC

算法示意图如下：
![](https://i.imgur.com/YZxtuCr.jpg)

####复制算法(Copying)
（1）与标记-清除算法相比，复制算法是一种相对高效的回收方法

（2）不适合于存活对象较多的场合，如老年代

（3）将对象的内存分为两块，每次使用其中的一块，在垃圾回收时，将正在使用的内存中存货的对象复制到未使用的内存中，

（4）复制算法的最大问题是：空间浪费 整合标记清理思想
![](https://i.imgur.com/23dPn94.jpg)


#### 标记-整理(Mark-Compact)
（1）复制收集算法在对象存活较多时就要执行较多的复制操作，效率将会降低。

（2）标记过程和“标记-清除”一样，后面不是直接收回，而是让所有存活的对象向一端移动，然后清理掉边界以外的内存

（3）适用于存活对象较多的场合，如老年代。

![](https://i.imgur.com/kHQgxdR.jpg)


#### 分代收集(Generational Collection)
（1）根据对象的存活周期的不同，将内存划分为几块，一般是把Java堆分为新生代和老年代
- Minor Collection：新生代垃圾收集。
- Full Collection：对新生代、老年代和永久代（JDK8 取消永久代，Full Collection扫描不到替代永久代的元空间）进行收集，又可以称作Majjor Collection。它的收集频率较低，耗时较长

当执行一次Minor Collection时，Eden空间的存活对象会被复制到To Survivor空间，并且之前经过一次Minor Collection并在From Survivor空间存活的仍年轻的对象也会复制到To Survivor空间。<br>
有两种情况Eden空间和From Survivor空间存活的对象不会复制到To Survivor空间，而是晋升到老年代。一种是存活的对象的分代年龄超过-XX:MaxTenuringThreshold（用于控制对象经历多少次Minor GC才晋升到老年代）所指定的阈值。另一种是To Survivor空间容量达到阈值。
（2）根据不同代的特点，选取合适的收集算法
- 少量对象存活，，适合复制算法
- 大量对象存活，适合标记清除和标记整理

![](https://i.imgur.com/OzP3aIA.jpg)

##4JVM垃圾回收器
垃圾收集器就是算法的具体的实现，不同的虚拟机会提过不同的垃圾收集器。并且提供参数供用户根据自己的应用特点和要求组合各个年代所使用的收集器。图中展示了jdk1.6中提供的6种作用于不同年代的收集器，两个收集器之间存在连线的话就说明它们可以搭配使用。没有最好的收集器，也没有万能的收集器，只有最合适的收集器。从Serial收集器到Parallel收集器，再到CMS收集器, G1收集器，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除。

####4.11. Serial收集器
单线程收集器，使用复制收集算法，收集时会暂停所有工作线程(我们将这件事情称之为Stop The World)，直到收集结束，虚拟机运行在Client模式时的默认新生代收集器。 优点是：简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器没有现成交互的开销。在堆比较小的情况下，一般停顿时间很短，是可以使用这种收集器的。如下图：

![](https://i.imgur.com/6sDjeup.jpg)

####4.2ParNew收集器
ParNew收集器就是Serial的多线程版本，除了使用多条收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一摸一样。ParNew收集器是许多运行在server模式下的虚拟机中首选的新生代收集器(一个原因是在除了serial收集器外，目前只有它能与CMS收集器配合使用)。<br>

ParNew收集器是使用-XX:+UseConcMarkSweepGC选项的默认新生代收集器；也可以用-XX:+UseParNewGC选项来强制指定它。ParNew收集器在单CPU环境中不比Serial效果好，甚至可能更差，两个CPU也不一定跑的过，但随着CPU数量的增加，性能会逐步增加。默认开启的收集线程数与CPU数量相同。在CPU数量很多的情况下，可以使用-XX:ParallelGCThreads参数来限制线程数。如下图

![](https://i.imgur.com/N1MfUnf.jpg)


####4.3Parallel Scavenge收集器
同ParNew一样是使用复制算法的新生代并行多线程收集器。

Parallel Scavenge的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。也被称为吞吐量优先收集器。所谓吞吐量就是CPU用于运行用户代码时间与CPU总消耗时间的比值。吞吐量=运行用户代码时间/运行用户代码时间+垃圾收集时间。

####4.4Serial Old收集器
是Serial的老年代版本，同样是单线程收集器，使用标记-整理算法。主要是client模式下的虚拟机使用。参考上面图Serial/Serial old.

两大用途：在JDK1.5及之前的版本中与Parallel Scavenge搭配使用；作为CMS收集器的后备预案。在并发收集发生Concurrent Mode Failure时使用

####4.6Parallel Old收集器
是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。在JDK1.6中才开始使用。由于之前的版本中，Parallel Scavenge只有使用Serial Old作为老年代收集器，其吞吐量优先的设计思路不能被很好的贯彻，在Parallel Old收集器出现后，这两者的配合主要用于贯彻这种思路。如下图：

![](https://i.imgur.com/11TdSTu.jpg)

#### 4.7CMS收集器
Concurrent Mark Sweep 以获取最短回收停顿时间为目标的收集器，比较理想的应用场景是B/S架构的服务器。如下图：

![](https://i.imgur.com/iPZOaCR.jpg)

基于标记-清除算法实现，运行过程分成4个步骤：
- a)初始标记(需要stop the world)，标记一下GC Roots能直接关联到的对象，速度很快
- b)并发标记，进行GC Roots Tracing的过程。
- c)重新标记(需要stop the world)，为了修正并发标记时用户继续运行而产生的标记变化，停顿时间比初始标记长，远比并发标记短。
- d)并发清除

缺点：
CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是因为占用了一部分CPU资源而导致应用程序变慢，总吞吐量就会降低。CMS默认启动的回收线程数为(CPU数量+3)/4。为了解决这一情况，有一个变种i-CMS,但目前并不推荐使用。

#### 4.8G1收集器

G1收集器与前面的CMS收集器相比有两个显著的改进：一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它不会产生空间碎片，这对于长时间运行的应用系统来说非常重要。二是它可以非常精确地控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。<br>
G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的来由）。区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。

----------------
请原谅后半部分复制了原文，原地址 [JVM垃圾收集器](JVM垃圾收集器[http://www.javaranger.com/archives/636](http://www.javaranger.com/archives/636)) <br>

感谢所有博主和作者的付出，才有我们这些小白学习的地方，谢谢你们。
学习语言从模仿开始，希望有一天可以用自己的语言表达出来。
